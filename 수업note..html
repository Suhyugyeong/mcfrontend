예, crypto.pbkdf2 함수의 파라미터들은 특정한 순서를 따라야 합니다. 함수
시그니처는 다음과 같습니다: password: 해싱할 비밀번호입니다. salt: 솔트 값으로,
보안을 강화하기 위해 사용됩니다. iterations: 해싱 알고리즘을 반복하는
횟수입니다. keylen: 생성되는 해시의 길이입니다. digest: 해시 알고리즘의
종류입니다. callback: 비동기 콜백 함수로, 계산이 완료되면 호출됩니다.
--------------------------------------------------- async 함수 내에서 await를
사용할 때, 에러 처리를 위해 try-catch 블록을 사용하는 것이 권장됩니다. 하지만
반드시 catch 메서드를 사용해야 하는 것은 아닙니다. 코드 전체를 try-catch로
감싸거나 catch 메서드를 사용하는 방식 중 하나를 선택할 수 있습니다. async
function exampleFunction() { try { const result = await someAsyncOperation();
console.log(result); } catch (error) { console.error('에러 발생:', error); } }
혹은 someAsyncOperation() .then((result) => { console.log(result); })
.catch((error) => { console.error('에러 발생:', error); });
--------------------------------------------------- Promise, async, await은
비동기 코드를 더 쉽게 작성하고 관리하기 위한 도구들입니다. Promise(프로미스):
비동기 작업의 성공 또는 실패를 나타내는 객체로, 콜백 지옥(callback hell)을
방지하고 가독성을 향상시킵니다. 비동기 작업이 완료되면 성공 또는 실패 상태를
알려주는데, .then()과 .catch() 메서드를 사용하여 각각 성공과 실패에 대한 처리를
할 수 있습니다. async/await: async 함수는 Promise를 반환하며, 해당 함수 안에서
비동기 작업을 동기적으로 작성할 수 있게 합니다. await 키워드는 Promise가
이행(resolve)될 때까지 기다리고, 그 결과를 반환합니다. 이를 통해 코드의 가독성이
향상되고, 비동기 코드를 동기식처럼 작성할 수 있습니다.
--------------------------------------------------- 선택지 axious, FetchAPI,
Superagent ... HTTP 요청 라이브러리...
--------------------------------------------------- '/user/'는 서버의 API
엔드포인트를 나타냅니다. 일반적으로 RESTful API에서 리소스를 식별하는 데
사용되는 URL 패턴 중 하나입니다. '/user/'는 사용자 리소스에 대한 엔드포인트를
나타내는 것으로 추측됩니다. 이 URL을 통해 사용자 정보를 읽거나 업데이트하려는
HTTP 요청을 서버로 전송할 수 있습니다. 예를 들어, PUT 메서드는 해당 엔드포인트에
새로운 사용자 정보를 업데이트하기 위해 사용될 수 있습니다. 이런 식의 URL
디자인은 RESTful API에서 흔히 사용되며, 클라이언트가 서버와 통신할 때 명확하고
일관된 방식으로 리소스를 식별하고 조작할 수 있도록 도와줍니다. /user/ 외에도
/customers/, /products/, /orders/등등 예약어라기보다는 API 디자인에서 권장되는
규칙과 관례에 따라 경로를 선택하는 것이 일반적입니다.
---------------------------------------------------엔드 포인트란?
엔드포인트(Endpoint)는 네트워크에서 어떤 서비스나 기기에 접근할 수 있는 주소
또는 URL을 말합니다. 웹 개발에서 주로 사용되며, 특히 웹 API에서 클라이언트가
서버에게 요청을 보낼 때 어떤 자원에 접근할 것인지를 명시하는데 사용됩니다.
---------------------------------------------------Set-Cookie는 HTTP 응답 헤더
중 하나로, 서버가 클라이언트에게 쿠키를 설정하도록 지시하는 역할을 합니다.
클라이언트가 이 헤더를 받으면, 브라우저는 해당 쿠키를 저장하고 나중에 동일한
서버에 대한 요청을 할 때마다 쿠키를 함께 전송합니다. 쿠키는 서버와 클라이언트
간에 상태를 유지하고 정보를 전송하기 위한 작은 데이터 조각입니다. 예를 들어,
로그인 상태 유지, 사용자의 환경 설정, 장바구니 등을 쿠키를 사용하여 관리할 수
있습니다. Set-Cookie: name=value; Expires=Sun, 21 Mar 2023 07:28:00 GMT; Path=/;
Domain=example.com; Secure; HttpOnly<br />
name=value: 쿠키의 이름과 값<br />
Expires: 쿠키의 만료 날짜 및 시간.<br />
Path: 쿠키가 적용되는 경로.<br />
Domain: 쿠키의 적용 도메인.<br />
Secure: HTTPS 연결에서만 쿠키 전송.<br />
HttpOnly: JavaScript에서 쿠키에 접근할 수 없도록 함.<br />
--------------------------------------------------- HTTP 응답 헤더는 서버가
클라이언트에게 보내는 HTTP 응답의 일부로, 응답의 메타데이터를 포함합니다. 이
헤더는 클라이언트와 서버 간의 통신을 지시하거나 제어하는 데 사용됩니다. 몇 가지
일반적인 HTTP 응답 헤더는 다음과 같습니다: Date: 응답이 생성된 날짜와 시간을
나타냅니다.<br />
Server: 서버의 소프트웨어 및 버전 정보를 포함합니다.<br />
Content-Type: 응답 본문의 미디어 타입을 정의합니다 (예: text/html,
application/json).<br />
Content-Length: 응답 본문의 크기를 나타냅니다.<br />
Location: 리다이렉트할 때 사용되며, 새로운 위치의 URL을 나타냅니다.<br />
Set-Cookie: 쿠키를 설정하기 위해 사용되며, 클라이언트에게 서버가 전송할 쿠키
정보를 담고 있습니다.<br />
Cache-Control: 캐시 동작을 제어하는 지시사항을 포함합니다.<br />
Expires: 리소스의 만료 날짜를 정의하여 캐시 동작을 제어합니다.<br />
Content-Encoding: 응답 본문의 압축 방법을 나타냅니다.<br />
---------------------------------------------------Location: '/': 이 부분은
리다이렉션을 의미합니다. 클라이언트가 요청한 페이지가 다른 위치로 이동해야 할 때
사용됩니다. 여기서는 클라이언트를 루트 경로('/')로 리다이렉션하도록 설정되어
있습니다. --------------------------------------------------- 먼저, Express
애플리케이션은 요청(request)이 발생하면 이를 처리하기 위해 여러 단계의 함수들이
차례로 실행되는데, 이때 사용되는 개념이 "미들웨어"와 "라우터"입니다. 미들웨어는
Express 애플리케이션에서 요청과 응답 사이에 위치하며, 요청과 응답을 처리하거나
조작하는 함수입니다. 각각의 미들웨어 함수는 요청 객체 (req), 응답 객체 (res),
그리고 다음 미들웨어로 제어를 전달하기 위한 next 콜백 함수를 인자로 받습니다.
미들웨어 함수의 주요 역할: 요청 전처리: 요청에 대한 검증, 로깅 등의 작업을
수행할 수 있습니다. 응답 후처리: 응답 데이터를 가공하거나 추가 작업을 수행할 수
있습니다. next()를 호출하여 다음 미들웨어로 흐름을 전달합니다. 라우터는
Express에서 특정 경로에 대한 요청을 처리하는 미들웨어의 그룹입니다. 즉, 특정
경로에 도달했을 때 어떤 동작을 수행할지를 정의하는 데 사용됩니다. 라우터의 주요
역할: 특정 경로에 대한 미들웨어를 등록하여 해당 경로의 요청을 처리합니다. 여러
개의 라우터를 생성하여 코드를 모듈화하고 유지보수성을 높일 수 있습니다.
---------------------------------------------------morgan은 Node.js 웹
애플리케이션의 로깅 미들웨어입니다. HTTP 요청에 대한 정보를 콘솔이나 로그 파일에
기록하여 애플리케이션의 동작을 추적하고 디버깅하는 데 도움이 됩니다. 주로 개발
중에 사용되며, 클라이언트의 요청과 서버의 응답에 대한 정보를 기록할 수 있습니다.
morgan('dev')에서 'dev'는 미들웨어의 로그 포맷을 지정하는 옵션입니다. 'dev'
옵션은 개발 환경에서 자주 사용되며, 응답 시간, 상태 코드, 요청 메서드, 요청 URL
등의 정보를 포함한 간결한 형식으로 로그를 생성합니다.
---------------------------------------------------249페이지 코드 resave: 세션
데이터가 변경되지 않았더라도 항상 저장할지 여부를 결정합니다. false로 설정하면
성능이 향상됩니다. saveUninitialized: 초기화되지 않은 세션을 저장할지 여부를
결정합니다. false로 설정하면 초기화되지 않은 세션은 저장되지 않습니다. secret:
세션을 서명하기 위한 비밀 키입니다. 세션 데이터를 안전하게 유지하기 위해
사용됩니다. 보안상 중요한 값이므로 환경 변수로부터 가져오도록 되어 있습니다.
cookie.httpOnly: 클라이언트에서 쿠키를 확인 및 수정할 수 있는 권한을 제한하기
위해 httpOnly 속성을 설정합니다. cookie.secure: HTTPS 프로토콜을 통해 통신할
때만 쿠키를 전송하도록 설정합니다. 보안 강화를 위한 옵션입니다. name: 세션
쿠키의 이름을 지정합니다. ---------------------------------------------------
//>npx nodemon app.js //[nodemon] app crashed - waiting for file changes before
starting... 대부분 단순 오타일때 발생(나같은경우) //lab9로 다시 확인해보기!!
--------------------------------------------------- ch6 - lab7 -
loginForm.html에서 regex=> (^|;): 문자열의 시작 또는 세미콜론 (;) 문자로
시작하는 패턴입니다. ?: 세미콜론 이후의 공백을 포함할 수도 있고 없을 수도
있습니다. name: 전달된 이름 변수에 해당하는 쿠키 이름을 의미합니다. =: 등호 (=)
문자 다음에 오는 패턴입니다. ([^;]*): 세미콜론을 제외한 모든 문자열을 나타내는
패턴입니다. (;|$): 세미콜론 또는 문자열의 끝으로 끝나는 패턴입니다.
--------------------------------------------------- flags: "a"는 Node.js의
fs.createWriteStream 메서드에서 사용되는 옵션 중 하나로, 파일을 열 때 어떤
작업을 수행할지를 지정합니다. 여기서 "a"는 "append"를 나타내며, 기존 파일에
이어서 쓰기를 수행하는 옵션입니다. 각각의 flags 옵션은 파일 열기 동작을
나타내며, 일반적으로 다음과 같은 값들을 가질 수 있습니다: "r": 읽기 모드 (read)
"w": 쓰기 모드 (write), 기존 파일 내용을 지우고 새로 씀 "a": 이어쓰기 모드
(append), 파일이 존재하면 파일 끝에서부터 이어서 씀 "r+": 읽기와 쓰기 모드 (read
and write) "w+": 읽기와 쓰기 모드, 기존 파일 내용을 지우고 새로 씀 "a+": 읽기와
이어쓰기 모드 따라서 flags: "a"로 설정된 경우, 파일이 이미 존재하면 파일
끝에서부터 이어서 쓰게 됩니다. 만약 파일이 존재하지 않으면 새로운 파일이
생성되어 이어쓰기 모드로 열립니다.
---------------------------------------------------"/" (루트 경로): "/"는
애플리케이션의 루트 경로를 나타냅니다. 이 경로는 애플리케이션에 접근하는 기본
경로로 사용되며, 대부분의 웹 사이트에서는 루트 경로에서 홈 페이지가 제공됩니다.
예를 들어, http://example.com/은 루트 경로에 해당합니다. "/about" (about 경로):
"/about"은 애플리케이션 내에서 "about"이라는 특정 경로를 나타냅니다. 이 경로는
사용자가 애플리케이션에서 "about" 페이지로 이동하기 위해 사용될 수 있습니다.
예를 들어, http://example.com/about은 "/about" 경로에 해당합니다.
--------------------------------------------------- 동적인 데이터를
클라이언트에게 전송하는 메서드로는... res.send(data): res.send() 메서드는 다양한
데이터 타입을 클라이언트에게 전송할 수 있는 범용적인 메서드입니다. 텍스트, HTML,
JSON, 버퍼, 그림 파일 등 다양한 종류의 데이터를 전송할 수 있습니다.
혹은,,,res.json(data): res.json() 메서드는 JSON 형식의 데이터를 클라이언트에게
전송합니다. 주로 객체나 배열과 같은 자바스크립트 객체를 JSON 형식으로 변환하여
전송합니다.이외에도 res.render() 등의 메서드도 사용될 수 있습니다. 선택한
메서드는 전송하려는 데이터의 형태와 클라이언트에서의 처리 방식에 따라
결정됩니다. --------------------------------------------------- // Nunjucks
템플릿 엔진을 Express 애플리케이션에서 사용할 수 있도록 설정하는 부분입니다. //
"views" 폴더에 템플릿 파일들이 있음을 가정합니다. //Express 애플리케이션과
Nunjucks를 연결합니다. 이렇게 설정하면 res.render를 통해 Nunjucks 템플릿을
사용할 수 있습니다. //템플릿 파일이 변경될 때 자동으로 감지하여 다시 로드하도록
설정합니다. 개발 중에 템플릿을 수정하고 저장하면 서버가 자동으로 변경을 감지하고
새로고침 없이 변경 사항이 반영됩니다.
